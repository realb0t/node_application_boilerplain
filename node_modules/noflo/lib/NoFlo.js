// Generated by CoffeeScript 1.3.1
(function() {
  var NoFlo, arrayport, component, graph, internalSocket, port;

  internalSocket = require("./InternalSocket");

  component = require("./Component");

  port = require("./Port");

  arrayport = require("./ArrayPort");

  graph = require("./Graph");

  NoFlo = (function() {

    NoFlo.name = 'NoFlo';

    NoFlo.prototype.processes = {};

    NoFlo.prototype.connections = [];

    NoFlo.prototype.graph = null;

    NoFlo.prototype.startupDate = null;

    function NoFlo(graph) {
      var _this = this;
      this.processes = {};
      this.connections = [];
      this.graph = graph;
      this.startupDate = new Date();
      this.graph.on('addNode', function(node) {
        return _this.addNode(node);
      });
      this.graph.on('removeNode', function(node) {
        return _this.removeNode(node);
      });
      this.graph.on('addEdge', function(edge) {
        return _this.addEdge(edge);
      });
      this.graph.on('removeEdge', function(edge) {
        return _this.removeEdge(edge);
      });
    }

    NoFlo.prototype.uptime = function() {
      return new Date() - this.startupDate;
    };

    NoFlo.prototype.load = function(component) {
      var implementation;
      if (typeof component === 'object') {
        return component;
      }
      try {
        if (component.substr(0, 1) === ".") {
          component = "" + (process.cwd()) + (component.substr(1));
        }
        implementation = require(component);
      } catch (error) {
        try {
          implementation = require("../components/" + component);
        } catch (localError) {
          error.message = "" + localError.message + " (" + error.message + ")";
          throw error;
        }
      }
      return implementation.getComponent();
    };

    NoFlo.prototype.addNode = function(node) {
      var process;
      if (this.processes[node.id]) {
        return;
      }
      process = {
        id: node.id
      };
      if (node.component) {
        process.component = this.load(node.component);
      }
      return this.processes[process.id] = process;
    };

    NoFlo.prototype.removeNode = function(node) {
      if (!this.processes[node.id]) {
        return;
      }
      return delete this.processes[node.id];
    };

    NoFlo.prototype.getNode = function(id) {
      return this.processes[id];
    };

    NoFlo.prototype.connectPort = function(socket, process, port, inbound) {
      if (inbound) {
        socket.to = {
          process: process,
          port: port
        };
        if (!(process.component.inPorts && process.component.inPorts[port])) {
          throw new Error("No inport '" + port + "' defined in process " + process.id);
          return;
        }
        return process.component.inPorts[port].attach(socket);
      }
      socket.from = {
        process: process,
        port: port
      };
      if (!(process.component.outPorts && process.component.outPorts[port])) {
        throw new Error("No outport '" + port + "' defined in process " + process.id);
        return;
      }
      return process.component.outPorts[port].attach(socket);
    };

    NoFlo.prototype.addDebug = function(socket) {
      var logSocket;
      logSocket = function(message) {
        return console.error("" + (socket.getId()) + " " + message);
      };
      socket.on("connect", function() {
        return logSocket("CONN");
      });
      socket.on("begingroup", function(group) {
        return logSocket("< " + group);
      });
      socket.on("disconnect", function() {
        return logSocket("DISC");
      });
      socket.on("endgroup", function(group) {
        return logSocket("> " + group);
      });
      return socket.on("data", function(data) {
        return logSocket("DATA");
      });
    };

    NoFlo.prototype.addEdge = function(edge) {
      var from, socket, to,
        _this = this;
      if (!edge.from.node) {
        return this.addInitial(edge);
      }
      socket = internalSocket.createSocket();
      if (this.debug) {
        this.addDebug(socket);
      }
      from = this.getNode(edge.from.node);
      if (!from) {
        throw new Error("No process defined for outbound node " + edge.from.node);
      }
      if (!from.component) {
        throw new Error("No component defined for outbound node " + edge.from.node);
      }
      if (!from.component.isReady()) {
        from.component.once("ready", function() {
          return _this.addEdge(edge);
        });
        return;
      }
      to = this.getNode(edge.to.node);
      if (!to) {
        throw new Error("No process defined for inbound node " + edge.to.node);
      }
      if (!to.component) {
        throw new Error("No component defined for inbound node " + edge.to.node);
      }
      if (!to.component.isReady()) {
        to.component.once("ready", function() {
          return _this.addEdge(edge);
        });
        return;
      }
      this.connectPort(socket, to, edge.to.port, true);
      this.connectPort(socket, from, edge.from.port, false);
      return this.connections.push(socket);
    };

    NoFlo.prototype.removeEdge = function(edge) {
      var connection, index, _i, _len, _ref, _ref1, _results;
      _ref = this.connections;
      _results = [];
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        connection = _ref[index];
        if (edge.to.node === connection.to.process.id && edge.to.port === connection.to.port) {
          if ((_ref1 = connection.to.process.component.inPorts[connection.to.port]) != null) {
            _ref1.detach(connection);
          }
          this.connections.splice(index, 1);
        }
        if (edge.from.node) {
          if (connection.from && edge.from.node === connection.from.process.id && edge.from.port === connection.from.port) {
            connection.from.process.component.inPorts[connection.from.port].detach(connection);
            _results.push(this.connections.splice(index, 1));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    NoFlo.prototype.addInitial = function(initializer) {
      var socket, to,
        _this = this;
      socket = internalSocket.createSocket();
      if (this.debug) {
        this.addDebug(socket);
      }
      to = this.getNode(initializer.to.node);
      if (!to) {
        throw new Error("No process defined for inbound node " + initializer.to.node);
      }
      if (!(to.component.isReady() || to.component.inPorts[initializer.to.port])) {
        to.component.setMaxListeners(0);
        to.component.once("ready", function() {
          return _this.addInitial(initializer);
        });
        return;
      }
      this.connectPort(socket, to, initializer.to.port, true);
      this.connections.push(socket);
      socket.connect();
      socket.send(initializer.from.data);
      return socket.disconnect();
    };

    return NoFlo;

  })();

  exports.createNetwork = function(graph, debug) {
    var edge, initializer, network, node, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (debug == null) {
      debug = false;
    }
    network = new NoFlo(graph);
    network.debug = debug;
    _ref = graph.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      network.addNode(node);
    }
    _ref1 = graph.edges;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      edge = _ref1[_j];
      network.addEdge(edge);
    }
    _ref2 = graph.initializers;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      initializer = _ref2[_k];
      network.addInitial(initializer);
    }
    return network;
  };

  exports.loadFile = function(file, success, debug) {
    if (debug == null) {
      debug = false;
    }
    return graph.loadFile(file, function(net) {
      return success(exports.createNetwork(net, debug));
    });
  };

  exports.saveFile = function(graph, file, success) {
    return graph.save(file, function() {
      return success(file);
    });
  };

  exports.Component = component.Component;

  exports.Port = port.Port;

  exports.ArrayPort = arrayport.ArrayPort;

  exports.Graph = graph.Graph;

  exports.graph = graph;

  exports.internalSocket = internalSocket;

}).call(this);
